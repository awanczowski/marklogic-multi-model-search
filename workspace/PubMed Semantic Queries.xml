<export><workspace name="Semantic Queries"><query name="Optic Multi-Model SJS" focus="false" listorder="2" taborder="2" active="true" database="3139451682592365772" server="2667156416309725469" database-name="data-hub-FINAL" server-name="data-hub-FINAL" mode="javascript">'use strict';

const op = require('/MarkLogic/optic');

// These values can come in from a users request. We will statically set them for this example.
const meshDesc = sem.iri("http://id.nlm.nih.gov/mesh/D003920");
const year = 1970;
const wordQuery = "research";
const limit = 100;


// Set-up a SPARQL query for query expanions
let sparqlQuery = `
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX meshv: &lt;http://id.nlm.nih.gov/mesh/vocab#&gt;
PREFIX mesh: &lt;http://id.nlm.nih.gov/mesh/&gt;

select ?label ?descriptor ?id ?uri
WHERE {
  ?descriptor meshv:broaderDescriptor @meshDesc .
  ?descriptor rdfs:label ?label .
  ?id meshv:hasDescriptor ?descriptor .
  ?uri rdfs:isDefinedBy ?id
}
`

// Join the two plans on the URI/IRI so the results can be further refined. 
// Configure a Schema (Table) plan that utilzies the generated view from the entity model.
// You can further refine the results using ML search library. 
op.fromView("HubArticle", "HubArticle")
    .where(
        cts.andQuery([
            cts.elementRangeQuery("publicationYear", "&gt;=", year),
            cts.wordQuery(wordQuery)
        ])
    )
    .joinInner(
        op.fromSPARQL(sparqlQuery, "MeSH"),
        op.on(op.viewCol("HubArticle", "id"),
            op.viewCol("MeSH", "id")))
    .limit(limit)
    .result(null, { "meshDesc": meshDesc })

</query><query name="Sparql Expansion MeSH" focus="false" listorder="1" taborder="1" active="true" database="3139451682592365772" server="2667156416309725469" database-name="data-hub-FINAL" server-name="data-hub-FINAL" mode="sparql">## query
# Diabetes Mellitus: http://id.nlm.nih.gov/mesh/D003920

PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX meshv: &lt;http://id.nlm.nih.gov/mesh/vocab#&gt;
PREFIX mesh: &lt;http://id.nlm.nih.gov/mesh/&gt;

select ?label ?descriptor ?id ?uri
WHERE {
  ?descriptor meshv:broaderDescriptor+ mesh:D003920 .
  ?id meshv:hasDescriptor ?descriptor .
  ?descriptor rdfs:label ?label .
  ?uri rdfs:isDefinedBy ?id
}

</query><query name="Optic Multi-Model XQY" focus="true" listorder="3" taborder="3" active="true" database="3139451682592365772" server="2667156416309725469" database-name="data-hub-FINAL" server-name="data-hub-FINAL" mode="xquery">xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic" at "/MarkLogic/optic.xqy";

declare option xdmp:mapping "false";
 
(: These values can come in from a users request. We will statically set them for this example. :)
let $meshDesc := sem:iri("http://id.nlm.nih.gov/mesh/D003920")
let $year := 1970
let $wordQuery := "research"
let $limit := 100

(: Set-up a SPARQL query for query expanions :)
(: Configure the SPARQL plan and set a view name. :)
let $mesh := 
  &lt;sparql&gt;&lt;![CDATA[
        PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
        PREFIX meshv: &lt;http://id.nlm.nih.gov/mesh/vocab#&gt;
        PREFIX mesh: &lt;http://id.nlm.nih.gov/mesh/&gt;

        select ?label ?descriptor ?id ?uri
        WHERE {
          ?descriptor meshv:broaderDescriptor @meshDesc .
          ?descriptor rdfs:label ?label .
          ?id meshv:hasDescriptor ?descriptor .
          ?uri rdfs:isDefinedBy ?id
        }
  ]]&gt;
  &lt;/sparql&gt;/text() 
  =&gt; op:from-sparql("MeSH")


(: Configure a Schema (Table) plan that utilzies the generated view from the entity model. :)
(: You can further refine the results using ML search library. :)
(: Join the two plans on the Article ID so the results can be further refined. :)
return 
   op:from-view("HubArticle", "HubArticle") 
    =&gt; op:where(cts:and-query((
        cts:element-range-query(xs:QName("publicationYear"), "&gt;=", $year),
        cts:word-query($wordQuery)
      )))
    =&gt; op:join-inner($mesh, op:on(op:view-col("HubArticle", "id"), op:view-col("MeSH", "id")))
    =&gt; op:limit($limit)
    =&gt; op:result("array", map:new((map:entry("meshDesc", $meshDesc))) )
</query></workspace></export>
